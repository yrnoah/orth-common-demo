import{r as o,j as e}from"./iframe-D12yBJYT.js";import{S as _}from"./Trigger-CBGbniTM.js";import{B as $}from"./Dropdown-D5JwdULb.js";import{d as E,a as R,b as I,O as L}from"./Overlay-Cvh_1rSA.js";import"./preload-helper-D9Z9MdNV.js";import"./IconArrowSm-B3wviign.js";import"./Portal-BcC3rkwp.js";import"./index-CLFaP9oP.js";import"./index-DihtluQp.js";import"./useCurrent-DBDDWVp7.js";import"./useMeasure-BC0zJ6WC.js";import"./IconCheckSmall-DH0saYPV.js";const p=l=>{const{defaultOpen:i,dropdownConfig:n,onSelect:s,options:c,selected:d,resetText:S,ref:u,...f}=l,[h,v]=o.useState(E),[m,b]=o.useState(()=>!!i),[k,j]=o.useState(()=>d&&c&&c.find(t=>t.key===d)?d:null),a=typeof d=="string"?d:k,w=o.useMemo(()=>typeof a!="string"||!c?null:c.find(r=>r.key===a)||null,[a,c]),M=o.useMemo(()=>({...n?.overlayContainerStyle||{},width:h.width}),[h.width,n?.overlayContainerStyle]),O=o.useCallback(t=>b(t),[]),T=o.useCallback(()=>{f.disabled||b(t=>!t)},[f.disabled]),x=!!f.disabled,C=o.useCallback(t=>{if(b(!1),x)return;if(!t){s&&s(null),j(null);return}const r=t;r.key!==a&&(s&&s(r),j(r.key))},[s,x,a]);return e.jsx($,{disableAnimation:!0,...n,visible:m,overlayContainerStyle:M,onVisibleChange:O,overlay:e.jsx(L,{options:c,disabled:x,onSelect:C,selected:a,resetText:S,visible:m}),children:e.jsx(_,{...f,$open:m,onClick:T,$text:w?.text??w?.key??a??d??void 0,ref:t=>{if(!t)return;const r=t.getBoundingClientRect(),y={width:r.width||I,height:r.height||R};if((y.width!==h.width||y.height!==h.height)&&v(y),!!u)if(typeof u=="function"){u(t);return}else u.current=t}})})};p.__docgenInfo={description:"@description design https://www.figma.com/design/JGFHYME2p7RpeMYcoMqooS/ODE-Library-1.0?node-id=8806-5741&t=a5kq8b0LVuQVrQrr-4",methods:[],displayName:"SelectMenu"};const U={title:"ODE Library/Selection/SelectMenu",tags:["autodocs"],component:p,argTypes:{children:{table:{disable:!0}},$text:{table:{disable:!0}},$size:{control:"select",options:["small","medium"]}}},V=[{key:"true"},{key:"false"},{key:"none"}],q=Array.from({length:200}).map((l,i)=>({key:`option_${i+1}`,text:`option ${i+1}`}));function z({...l}){const{style:i,...n}=l;return e.jsxs(e.Fragment,{children:[e.jsx("a",{target:"blank",href:"https://www.figma.com/design/JGFHYME2p7RpeMYcoMqooS/ODE-Library-1.0?node-id=8806-5741&t=a5kq8b0LVuQVrQrr-4",rel:"noreferrer",children:"design reference"}),e.jsx("br",{}),e.jsx("br",{}),e.jsx("h4",{children:"- default trigger"}),e.jsx("br",{}),e.jsx(p,{...n}),e.jsx("br",{}),e.jsx("br",{}),e.jsx("h4",{children:"- trigger with long text option"}),e.jsx("br",{}),e.jsx(p,{...n,options:B}),e.jsx("br",{}),e.jsx("br",{}),e.jsx("h4",{children:"- default open = true"}),e.jsx("br",{}),e.jsx(p,{...n,defaultOpen:!0,style:i}),e.jsx("br",{}),e.jsx("br",{}),e.jsx("div",{style:{height:"200vh"}}),e.jsxs("h4",{children:["- trigger with auto position (top or bottom) ",e.jsx("br",{}),"- if bottom & options' height is larger than window's height, options will be fix to fit window's bottom"]}),e.jsx("br",{}),e.jsx(p,{...n,options:q,style:i,ref:s=>{console.info("get trigger element from ref",s)}}),e.jsx("br",{}),e.jsx("br",{}),e.jsx("div",{style:{height:"200vh"}})]})}const g={render:z,args:{$size:"small",$placeholder:"select value",defaultOpen:!1,disabled:!1,style:{width:"50vw"},dropdownConfig:{triggerType:"click"},options:V,resetText:"-- please choose",onSelect:l=>console.info("onOptionSelect",l)}},B=[{key:"true",text:`The lexical units are combined to form even larger building blocks such as expressions according to the rules given by the expression part of the Modelica grammar in appendix A. For example, they can be built from operators, function references, components, or component references (referring to components) and literals. Each expression has a type and a variability. 
 This chapter describes the evaluation rules for expressions, the concept of expression variability, built-in mathematical operators and functions, and the built-in special Modelica operators with function syntax. 
 Expressions can contain variables and constants, which have types, predefined or user defined. The predefined built-in types of Modelica are Real, Integer, Boolean, String, and enumeration types which are presented in more detail in section 4.9.`},{key:"false",text:"It is also possible to define functions and call them in a normal fashion. The function call syntax for both positional and named arguments is described in section 12.4.1 and for vectorized calls in section 12.4.4. The built-in array functions are given in section 10.1.1 and other built-in operators in section 3.7."},{key:"none"}];g.parameters={...g.parameters,docs:{...g.parameters?.docs,source:{originalSource:`{
  render: SelectMenuStory,
  args: {
    $size: "small",
    $placeholder: "select value",
    defaultOpen: false,
    disabled: false,
    style: {
      width: "50vw"
    },
    dropdownConfig: {
      triggerType: "click"
    },
    options,
    resetText: "-- please choose",
    onSelect: item => console.info("onOptionSelect", item)
  }
}`,...g.parameters?.docs?.source}}};const X=["SelectionTrigger"];export{g as SelectionTrigger,X as __namedExportsOrder,U as default};
